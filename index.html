<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>KSP Tracker Final Moving Vessels</title>
<style>
html, body {margin:0; height:100%; overflow:hidden; background:#000; font-family:sans-serif; color:#fff;}
#timeLabel {position:absolute; top:10px; left:10px; background:rgba(0,0,0,0.6); padding:6px 10px; border-radius:6px;}
#planetSelector {position:absolute; top:50px; left:10px; background:rgba(0,0,0,0.6); padding:6px 10px; border-radius:6px;}
#infoPanel {position:absolute; left:0; top:100px; width:250px; background:rgba(0,0,0,0.8); padding:10px; border-radius:6px; display:none;}
#infoPanel a {color:cyan; text-decoration:none;}
</style>
</head>
<body>
<div id="timeLabel">UTC: <span id="utcTime">â€”</span></div>
<div id="planetSelector">
<select id="planetDropdown">
  <option value="earth">Earth</option>
  <option value="moon">Moon</option>
  <option value="mars">Mars</option>
</select>
</div>
<div id="infoPanel">
<div id="vesselName"></div>
<div id="vesselDesc"></div>
<a id="vesselYT" target="_blank">YouTube</a>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.141.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.141.0/examples/js/controls/OrbitControls.js"></script>

<script>
// Constants
const G = 6.67430e-11;
const planetGM = { earth:3.986004418e14, moon:4.9048695e12, mars:4.282837e13 };

// Planet textures
const planetTextures = {earth:'earth.jpg', moon:'moon.png', mars:'mars.jpg'};

// Vessels
const vessels = [
{ id:"iss_recreation", type:"keplerian", centralBody:"earth", epoch:1737176400, a:6771000, e:0.0005, i:51.64*Math.PI/180, raan:0, argPeri:0, M0:0, info:{name:"ISS Recreation", description:"International Space Station recreated in KSP RSS/RO.", youtube:"https://www.youtube.com/watch?v=VIDEO1"} },
{ id:"apollo8_recreation", type:"keplerian", centralBody:"moon", epoch:1737176400, a:1838000, e:0.05, i:1.5*Math.PI/180, raan:0, argPeri:0, M0:0, info:{name:"Apollo 8 Recreation", description:"First crewed mission to orbit the Moon.", youtube:"https://www.youtube.com/watch?v=VIDEO2"} }
];

// Scene setup
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 1, 1e8);
camera.position.set(0,0,1.2e7);
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);
const controls = new THREE.OrbitControls(camera, renderer.domElement);

// Lights
scene.add(new THREE.AmbientLight(0xffffff,0.6));
const dirLight = new THREE.DirectionalLight(0xffffff,0.4);
dirLight.position.set(5e6,5e6,5e6);
scene.add(dirLight);

// Circle sprite texture
function createCircleTexture(color='white', size=64){
  const canvas = document.createElement('canvas');
  canvas.width = canvas.height = size;
  const ctx = canvas.getContext('2d');
  ctx.fillStyle = color;
  ctx.beginPath();
  ctx.arc(size/2,size/2,size/2,0,Math.PI*2);
  ctx.fill();
  return new THREE.CanvasTexture(canvas);
}

// Text canvas for labels
function createTextCanvas(text){
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  ctx.font = 'Bold 100px sans-serif';
  const w = ctx.measureText(text).width;
  canvas.width = w;
  canvas.height = 120;
  ctx.font = 'Bold 100px sans-serif';
  ctx.fillStyle = 'white';
  ctx.fillText(text, 0, 100);
  return canvas;
}

const circleTex = createCircleTexture('white',64);

let currentPlanet = 'earth';
let planetMesh;
let vesselSprites = [];
let orbitLines = [];

// Planet creation
function createPlanet(name){
  if(planetMesh) scene.remove(planetMesh);
  const radius = name==='moon'?1737e3:name==='earth'?6371e3:3390e3;
  planetMesh = new THREE.Mesh(
    new THREE.SphereGeometry(radius,64,64),
    new THREE.MeshStandardMaterial({map:new THREE.TextureLoader().load(planetTextures[name])})
  );
  scene.add(planetMesh);

  vesselSprites.forEach(v=>scene.remove(v.mesh), scene.remove(v.label));
  orbitLines.forEach(l=>scene.remove(l.line));
  vesselSprites=[]; orbitLines=[];

  vessels.filter(v=>v.centralBody===name).forEach((v,i)=>{
    // Sprite
    const spriteMat = new THREE.SpriteMaterial({map:circleTex, depthTest:false});
    const sprite = new THREE.Sprite(spriteMat);
    sprite.renderOrder = 999;
    scene.add(sprite);

    // Label
    const textTex = new THREE.CanvasTexture(createTextCanvas(v.info.name));
    const labelMat = new THREE.SpriteMaterial({map:textTex, depthTest:false});
    const labelSprite = new THREE.Sprite(labelMat);
    labelSprite.scale.set(2e5, 5e4, 1);
    scene.add(labelSprite);

    // Orbit line
    const steps=256; const points=[]; const alphas = new Float32Array(steps+1);
    for(let j=0;j<=steps;j++){
      const M = 2*Math.PI*j/steps;
      points.push(keplerToCartesian(v.a,v.e,v.i,v.raan,v.argPeri,M));
      alphas[j] = 0;
    }
    const geom = new THREE.BufferGeometry().setFromPoints(points);
    geom.setAttribute('alpha', new THREE.BufferAttribute(alphas,1));
    const mat = new THREE.ShaderMaterial({
      uniforms:{color:{value:new THREE.Color(0xffffff)}},
      vertexShader:`attribute float alpha; varying float vAlpha; void main(){vAlpha=alpha; gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);}`,
      fragmentShader:`uniform vec3 color; varying float vAlpha; void main(){gl_FragColor=vec4(color,vAlpha);}`,
      transparent:true,
      depthTest:false
    });
    const line = new THREE.Line(geom, mat);
    scene.add(line);
    orbitLines.push({line, points, alphas});

    vesselSprites.push({mesh:sprite,label:labelSprite,data:v});
  });
}
createPlanet(currentPlanet);
document.getElementById('planetDropdown').addEventListener('change',e=>{
  currentPlanet=e.target.value;
  createPlanet(currentPlanet);
});

// Kepler -> Cartesian
function keplerToCartesian(a,e,i,raan,argPeri,M){
  const E=M;
  let x=a*(Math.cos(E)-e);
  let y=a*Math.sqrt(1-e*e)*Math.sin(E);
  let z=0;
  const cosAP=Math.cos(argPeri), sinAP=Math.sin(argPeri);
  let x1=x*cosAP - y*sinAP, y1=x*sinAP + y*cosAP, z1=z;
  const cosI=Math.cos(i), sinI=Math.sin(i);
  let x2=x1, y2=y1*cosI - z1*sinI, z2=y1*sinI + z1;
  const cosR=Math.cos(raan), sinR=Math.sin(raan);
  return new THREE.Vector3(x2*cosR - y2*sinR, x2*sinR + y2*cosR, z2);
}

// Animate
function animate(){
  requestAnimationFrame(animate);
  const now = Date.now()/1000;

  if(currentPlanet==='earth') planetMesh.rotation.y += (2*Math.PI)/(24*60*60)/60;
  if(currentPlanet==='moon') planetMesh.rotation.y += (2*Math.PI)/(27.3*24*60*60)/60;
  if(currentPlanet==='mars') planetMesh.rotation.y += (2*Math.PI)/(24.6*60*60)/60;

  vesselSprites.forEach((v,i)=>{
    const mu = planetGM[v.data.centralBody];
    const n = Math.sqrt(mu/Math.pow(v.data.a,3));
    const M = v.data.M0 - n*(now - v.data.epoch);
    const pos = keplerToCartesian(v.data.a,v.data.e,v.data.i,v.data.raan,v.data.argPeri,M);
    v.mesh.position.copy(pos);

    // Label above sprite
    v.label.position.copy(pos).add(new THREE.Vector3(0,2e5,0));
    const camPos = camera.position.clone();
    const lookAt = new THREE.Vector3(camPos.x, v.label.position.y, camPos.z);
    v.label.lookAt(lookAt);

    // Orbit fade from vessel
    const lineData = orbitLines[i];
    let closestIdx = 0;
    let minDist = Infinity;
    for(let j=0;j<lineData.points.length;j++){
      const d = pos.distanceTo(lineData.points[j]);
      if(d<minDist){ minDist=d; closestIdx=j; }
    }
    for(let j=0;j<lineData.points.length;j++){
      lineData.alphas[j] = 0.3*((j-closestIdx+lineData.points.length)%lineData.points.length)/lineData.points.length;
    }
    lineData.line.geometry.attributes.alpha.needsUpdate=true;
  });

  document.getElementById('utcTime').textContent=new Date().toISOString().replace('T',' ').replace('Z',' UTC');
  controls.update(); renderer.render(scene,camera);
}
animate();

// Vessel click info
renderer.domElement.addEventListener('pointerdown', e=>{
  const mouse=new THREE.Vector2();
  mouse.x = (e.clientX/window.innerWidth)*2-1;
  mouse.y = -(e.clientY/window.innerHeight)*2+1;
  const ray=new THREE.Raycaster(); ray.setFromCamera(mouse,camera);
  const hit = vesselSprites.find(v=>ray.intersectObject(v.mesh).length>0);
  if(hit){
    const v=hit.data;
    document.getElementById('vesselName').innerText=v.info.name;
    document.getElementById('vesselDesc').innerText=v.info.description;
    const yt=document.getElementById('vesselYT'); yt.href=v.info.youtube; yt.style.display='block';
    document.getElementById('infoPanel').style.display='block';
  }
});

window.addEventListener('resize',()=>{
  camera.aspect=window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth,window.innerHeight);
});
</script>
</body>
</html>
