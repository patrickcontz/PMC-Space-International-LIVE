<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>KSP Tracker Final Moving Vessels</title>
<style>
html, body {margin:0; height:100%; overflow:hidden; background:#000; font-family:sans-serif; color:#fff;}
#timeLabel {position:absolute; top:10px; left:10px; background:rgba(0,0,0,0.6); padding:6px 10px; border-radius:6px;}
#planetSelector {position:absolute; top:50px; left:10px; background:rgba(0,0,0,0.6); padding:6px 10px; border-radius:6px;}
#infoPanel {position:absolute; left:0; top:100px; width:250px; background:rgba(0,0,0,0.8); padding:10px; border-radius:6px; display:none;}
#infoPanel a {color:cyan; text-decoration:none;}
</style>
</head>
<body>
<div id="timeLabel">UTC: <span id="utcTime">—</span></div>
<div id="planetSelector">
<select id="planetDropdown">
  <option value="earth">Earth</option>
  <option value="moon">Moon</option>
  <option value="mars">Mars</option>
</select>
</div>
<div id="infoPanel">
<div id="vesselName"></div>
<div id="vesselDesc"></div>
<a id="vesselYT" target="_blank">YouTube</a>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.141.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.141.0/examples/js/controls/OrbitControls.js"></script>
<script>
// Constants
const planetGM = { earth: 3.986004418e14, moon: 4.9048695e12, mars: 4.282837e13 };
const planetTextures = { earth:'earth.jpg', moon:'moon.png', mars:'mars.jpg' };

// Vessels
const vessels = [
  { "id":"iss_recreation","type":"keplerian","centralBody":"earth","epoch":1737176400,"a":6771000,"e":0.0005,"i":51.64*Math.PI/180,"raan":0,"argPeri":0,"M0":0,"info":{"name":"ISS Recreation","description":"International Space Station recreated in KSP RSS/RO.","youtube":"https://www.youtube.com/watch?v=VIDEO1"} },
  { "id":"apollo8_recreation","type":"keplerian","centralBody":"moon","epoch":1737176400,"a":1838000,"e":0.05,"i":1.5*Math.PI/180,"raan":0,"argPeri":0,"M0":0,"info":{"name":"Apollo 8 Recreation","description":"First crewed mission to orbit the Moon.","youtube":"https://www.youtube.com/watch?v=VIDEO2"} }
];

// Scene setup
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 1, 1e8);
camera.position.set(0,0,1.2e7);
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);
const controls = new THREE.OrbitControls(camera, renderer.domElement);
scene.add(new THREE.AmbientLight(0xffffff,0.6));
const dirLight = new THREE.DirectionalLight(0xffffff,0.4);
dirLight.position.set(5e6,5e6,5e6); scene.add(dirLight);

// Circle sprite texture
function createCircleTexture(color='white', size=64){
  const canvas=document.createElement('canvas'); canvas.width=canvas.height=size;
  const ctx=canvas.getContext('2d');
  ctx.fillStyle=color; ctx.beginPath();
  ctx.arc(size/2,size/2,size/2,0,Math.PI*2); ctx.fill();
  return new THREE.CanvasTexture(canvas);
}
const circleTex=createCircleTexture('white',64);

// Globals
let currentPlanet='earth', planetMesh;
let vesselSprites=[], orbitLines=[];

// Planet + vessels
function createPlanet(name){
  if(planetMesh) scene.remove(planetMesh);

  const radius = name==='moon'?1737e3:name==='earth'?6371e3:3390e3;
  planetMesh = new THREE.Mesh(
    new THREE.SphereGeometry(radius,64,64),
    new THREE.MeshStandardMaterial({map:new THREE.TextureLoader().load(planetTextures[name])})
  );
  scene.add(planetMesh);

  // cleanup old
  vesselSprites.forEach(vs=>{
    scene.remove(vs.mesh);
    scene.remove(vs.label);
  });
  orbitLines.forEach(o=>scene.remove(o.line));
  vesselSprites=[]; orbitLines=[];

  vessels.filter(vessel=>vessel.centralBody===name).forEach((vessel,i)=>{
    // Indicator
    const mat = new THREE.SpriteMaterial({map:circleTex, depthTest:false});
    const sprite = new THREE.Sprite(mat);
    sprite.renderOrder=999; 
    scene.add(sprite);

    // Label texture
    const canvas=document.createElement('canvas'); canvas.width=256; canvas.height=64;
    const ctx=canvas.getContext('2d');
    ctx.font='Bold 48px sans-serif'; // higher res, will be scaled down
    ctx.fillStyle='white'; ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillText(vessel.info.name,128,32);
    const texture=new THREE.CanvasTexture(canvas);
    texture.minFilter = THREE.LinearFilter;
    const labelMat=new THREE.SpriteMaterial({map:texture,transparent:true, depthTest:false});
    const label=new THREE.Sprite(labelMat); 
    scene.add(label);

    vesselSprites.push({mesh:sprite,label,data:vessel,orbitIndex:i});

    // Orbit line
    const steps=256; const points=[]; const alphas=new Float32Array(steps+1);
    for(let j=0;j<=steps;j++){
      const M=2*Math.PI*j/steps;
      points.push(keplerToCartesian(vessel.a,vessel.e,vessel.i,vessel.raan,vessel.argPeri,M));
      alphas[j]=0;
    }
    const geometry=new THREE.BufferGeometry().setFromPoints(points);
    geometry.setAttribute('alpha', new THREE.BufferAttribute(alphas,1));
    const material=new THREE.ShaderMaterial({
      uniforms:{color:{value:new THREE.Color(0xffffff)}},
      vertexShader:`attribute float alpha; varying float vAlpha; 
        void main(){vAlpha=alpha; gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);}`,
      fragmentShader:`uniform vec3 color; varying float vAlpha; 
        void main(){gl_FragColor=vec4(color,vAlpha);}`,
      transparent:true, depthTest:false
    });
    const line=new THREE.Line(geometry,material); scene.add(line);
    orbitLines.push({line,points,alphas});
  });
}
createPlanet(currentPlanet);
document.getElementById('planetDropdown').addEventListener('change',e=>{
  currentPlanet=e.target.value; createPlanet(currentPlanet);
});

// Kepler → Cartesian
function keplerToCartesian(a,e,i,raan,argPeri,M){
  const E=M;
  let x=a*(Math.cos(E)-e); let y=a*Math.sqrt(1-e*e)*Math.sin(E); let z=0;
  const cosAP=Math.cos(argPeri), sinAP=Math.sin(argPeri);
  let x1=x*cosAP - y*sinAP, y1=x*sinAP + y*cosAP, z1=z;
  const cosI=Math.cos(i), sinI=Math.sin(i);
  let x2=x1, y2=y1*cosI - z1*sinI, z2=y1*sinI + z1;
  const cosR=Math.cos(raan), sinR=Math.sin(raan);
  return new THREE.Vector3(x2*cosR - y2*sinR, x2*sinR + y2*cosR, z2);
}

// Animate
function animate(){
  requestAnimationFrame(animate);
  const now = Date.now()/1000;

  // Rotate planet
  if(currentPlanet==='earth') planetMesh.rotation.y += (2*Math.PI)/(24*60*60)/60;
  if(currentPlanet==='moon') planetMesh.rotation.y += (2*Math.PI)/(27.3*24*60*60)/60;
  if(currentPlanet==='mars') planetMesh.rotation.y += (2*Math.PI)/(24.6*60*60)/60;

              vesselSprites.forEach((vs, i) => {
                  const mu = planetGM[vs.data.centralBody];
                  const n = Math.sqrt(mu / Math.pow(vs.data.a, 3));
                  const M = vs.data.M0 - n * (now - vs.data.epoch);
                  const pos = keplerToCartesian(vs.data.a, vs.data.e, vs.data.i, vs.data.raan, vs.data.argPeri, M);
                  vs.mesh.position.copy(pos);
              
                  // Bigger indicator
                  const dist = camera.position.distanceTo(pos);
                  vs.mesh.scale.set(dist * 0.002, dist * 0.002, 1);
              
                  // Label above indicator
                  const labelOffset = dist * 0.0005; // tweak to move label slightly above
                  const labelPos = pos.clone();
                  labelPos.y += labelOffset; // move upward
                  vs.label.position.copy(labelPos);
              
                  // Keep label aspect ratio correct
                  const tex = vs.label.material.map;
                  const aspect = tex.image.width / tex.image.height;
                  const labelScale = dist * 0.001;
                  vs.label.scale.set(labelScale * aspect, labelScale, 1);
              
                  // Label faces camera, stays horizontal
                  const camQuat = camera.quaternion.clone();
                  const euler = new THREE.Euler().setFromQuaternion(camQuat);
                  euler.x = 0; euler.z = 0;
                  vs.label.quaternion.setFromEuler(euler);
              
                  // Orbit fade
                  const orbit = orbitLines[vs.orbitIndex];
                  const idx = Math.floor(((M % (2 * Math.PI)) / (2 * Math.PI)) * orbit.points.length);
                  for (let j = 0; j < orbit.points.length; j++) {
                      const diff = (j - idx + orbit.points.length) % orbit.points.length;
                      orbit.alphas[j] = Math.max(0, 0.3 * (1 - diff / orbit.points.length));
                  }
                  orbit.line.geometry.attributes.alpha.needsUpdate = true;
              });

  document.getElementById('utcTime').textContent=new Date().toISOString().replace('T',' ').replace('Z',' UTC');
  controls.update(); renderer.render(scene,camera);
}
animate();

// Click handler
renderer.domElement.addEventListener('pointerdown', e=>{
  const mouse=new THREE.Vector2();
  mouse.x=(e.clientX/window.innerWidth)*2-1;
  mouse.y=-(e.clientY/window.innerHeight)*2+1;
  const ray=new THREE.Raycaster(); ray.setFromCamera(mouse,camera);
  const hit=vesselSprites.find(v=>ray.intersectObject(v.mesh).length>0);
  if(hit){
    const v=hit.data;
    document.getElementById('vesselName').innerText=v.info.name;
    document.getElementById('vesselDesc').innerText=v.info.description;
    const yt=document.getElementById('vesselYT'); yt.href=v.info.youtube; yt.style.display='block';
    document.getElementById('infoPanel').style.display='block';
  }
});

window.addEventListener('resize',()=>{
  camera.aspect=window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth,window.innerHeight);
});
</script>
</body>
</html>
